---
title: "SOA Predictive Analytics Exam, Introduction to R"

---

In many cases a chunk is presented with room for you to enter code. It is then followed by a chunk with a solution.

# Basic Math Section

Work with the following code after reading Section 4.1. As a reminder, when writing R chunks you do not include the ">" as seen in the text. You will not see the result until you click the green triangle.

```{r}
# Add 3 plus 5 and then multiply the sum by 4 to obtain 32.


# Calculate the average of 3, 7, and 8 to obtain 6.

```  

```{r}
# Add 3 plus 5 and then multiply the sum by 4 to obtain 32.
(3 + 5) * 4

# Calculate the average of 3, 7, and 8 to obtain 6.
(3 + 7 + 8) / 3
```  

# Variables Section

Work with the following code after reading Section 4.2.

```{r}
# Assign 3 to x, 5 to y and 4 to z. Then complete the first calculation from the previous chunk.

```

```{r}
# Assign 3 to x, 5 to y and 4 to z. Then complete the first calculation from the previous chunk.
x <- 3
y <- 5
z <- 4
(x + y) * z
```

```{r}
# You should see x, y, and z and their values in the Environment area (usually upper right). With the three variables in place, use rm() to remove z and then retry the calculation (which should produce an error).

```

```{r}
rm(z)
(x + y) * z
```

# Data Types Section

Work with the following code after reading Section 4.3. We now begin each chunk with rm(list=ls()). This removes all variables from the environment so you start with a clean slate. Comment it out (with #) if you want to preserve earlier variables.

```{r}
rm(list = ls())
# Set x equal to 5 and test to see if it is numeric.


# Set y equal to the character value "yyy" and test to see if it is a character variable.


# Set z as a factor variable with value "yyy" and test to see if it is a factor variable.


# Set w as y == z and test to see if it is a logical variable. Does it have the value you would expect?


# Set e as the date February 29, 1996 and f as the date March 1, 1997. Set g = f-e and determine the number of days between these dates. Use as.numeric on each date and then subtract, putting the result in h and observe any differences from g.


```

```{r}
rm(list = ls())

# Set x equal to 5 and test to see if it is numeric.
x <- 5
class(x)

# Set y equal to the character value "yyy" and test to see if it is a character variable.
y <- "yyy"
class(y)
y

# Set z as a factor variable with value "yyy" and test to see if it is a factor variable.
z <- factor("yyy")
class(z)
z

# Set w as y == z and test to see if it is a logical variable. Does it have the value you would expect?
w <- y == z
class(w)
w
# R considers them as equal.

# Set e as the date February 29, 1996 and f as the date March 1, 1997. Set g = f-e and determine the number of days between these dates. Use as.numeric on each date and then subtract, putting the result in h and observe any differences from g.
e <- as.Date("1996-02-29")
f <- as.Date("1997-03-01")
g <- f - e
g
as.numeric(f) - as.numeric(e)

```

# Vectors Section, Part 1

Work with the following code after reading Section 4.4.1.

```{r}
rm(list = ls())

# Create two vectors, x with elements 1,2,3,4,5 and y with elements 5,4,3,2,1.


# Add 3 to each element of x, do not save the result, but verify the answer 4,5,6,7,8.


# Square each member of y, do not save the result, but verify the answer is 25,16,9,4,1.


# Add x and y, verify that the answer is 6,6,6,6,6.


# Create the vector z with elements 8,9,10. Verity that x+z is 9,11,13,12,14.


# Check to see which elements of x are less than the corresponding element of y.


# Access the fifth element of x.

```

```{r}
rm(list = ls())

# Create two vectors, x with elements 1,2,3,4,5 and y with elements 5,4,3,2,1.
x <- c(1, 2, 3, 4, 5)
y <- c(5, 4, 3, 2, 1)

# Add 3 to each element of x, do not save the result, but verify the answer is 4,5,6,7,8.
x + 3

# Square each member of y, do not save the result, but verify the answer is 25,16,9,4,1.
y^2

# Add x and y, verify that the answer is 6,6,6,6,6.
x + y

# Create the vector z with elements 8,9,10. Verify that x+z is 9,11,13,12,14.
z <- c(8, 9, 10)
x + z
# Note that R generates a warning. Warnings do not prevent the code from running or from providing an answer. Warnings provide information that may aid in your interpretation of the output or may indicate that something might be wrong, but not fatal. When R works with vectors of different lengths it reuses the shorter vector, in this case treating z as if it were (8, 9, 10, 8, 9). As long as that is what was intended, the warning can be ignored.

# Check to see which elements of x are less than the corresponding element of y.
x < y

# Access the fifth element of x.
x[5]
```

# Vectors Section, Part 2

Work with the following code after reading Section 4.4.2.

```{r}
rm(list = ls())

# You will work with the following vector that contains one of four codes (MS = male smoker, MN = male nonsmoker, FS = female smoker, FN = female nonsmoker)

s <- c("MN", "MN", "FS", "FN", "MS", "FN", "FN", "MN", "MN", "MS", "FN")

s

class(s)

# Observe that s is a vector of characters

# Convert s to s.factor using the as.factor function and then display s.factor. There should be no quotation marks. Check the class of this new vector.


# Check the integer values of the elements to see how they were coded.

```

```{r}
rm(list = ls())

# You will work with the following vector that contains one of four codes (MS = male smoker, MN = male nonsmoker, FS = female smoker, FN = female nonsmoker).

s <- c("MN", "MN", "FS", "FN", "MS", "FN", "FN", "MN", "MN", "MS", "FN")

s

class(s)

# Observe that s is a vector of characters.

# Convert s to s_factor using the as.factor function and then display s_factor. There should be no quotation marks. Check the class of this new vector.
s_factor <- as.factor(s)
class(s_factor)

# Check the integer values of the elements to see how they were coded.
as.numeric(s_factor)
```

# Functions Section

Work with the following code after reading Sections 4.5 and 4.6.

```{r}
rm(list = ls())

# Create the vector x of length 1000 that contains randomly generated uniform numbers between 0 and 1. Hint: use the function runif (for "random uniform" not "run if") and use ?runif in the Console to determine the arguments.


# Use functions to calculate the sample mean and variance of x. Your values should be close to 1/2 and 1/12. Hint: the function to calculate the variance is not called "variance."


# Variances can be calculated by dividing by n or by n-1. Calculate the variance using basic math functions to see which denominator R is using.

```


```{r}
rm(list = ls())

set.seed(1949) # The set.seed function initializes the random number generator. By setting it here, everyone running this chunk should get the same answer.

# Create the vector x of length 1000 that contains randomly generated uniform numbers between 0 and 1. Hint: use the function runif (for "random uniform" not "run if") and search for help (type ?runif in the console) to determine the arguments.
x <- runif(1000)

# Use functions to calculate the sample mean and variance of x. Your values should be 0.49978 and 0.08597. Hint: the function to calculate the variance is not called "variance."
mean(x)
var(x)

# Variances can be calculated by dividing by n or by n-1. Calculate the variance using basic math functions to see which denominator R is using.
v <- sum((x - mean(x))^2)
v / 1000
v / 999 # This is the one used by var()
```

# Missing Data Section

Work with the following code after reading Section 4.7. For this chunk, the work is already done.

```{r}
rm(list = ls())

# Use this vector with some missing values.
x <- c(1, 2, NA, 4, 5, 6)

# Check to see if it has any missing values.
is.na(x) # This displays the status of each of the elements
any(is.na(x)) # This will be true as long as there is at least one NA in the vector

# Try and compute the mean, first using mean() and then using
# mean(, na.rm=TRUE).
mean(x)
mean(x, na.rm = TRUE)

# Use the following to see the difference between NA and NULL.
y <- c(1, 2, NA, 4)
y
is.na(y)
is.null(y)
y <- NULL
y
is.na(y)
is.null(y)
```

# Data Structures Section

Work with the following code after reading Section 5.1.

```{r}
rm(list = ls())

# Work with the following three vectors:
age <- c(35, 42, 51, 38, 19, 45, 63)
amount <- c(1, 3, 2, 5, 2, 3, 7)
type <- as.factor(c("term", "universal", "term", "whole", "universal", "term", "whole"))

# Use the data.frame function to make a data frame from these three vectors and then display the data frame. Note that these variables were named in advance, so names didn't have to be assigned. Note that the data frame deduced that the first two variables are numeric and the third a factor variable. Assign the name df to your data frame.

df <- data.frame(age, amount, type)

# Determine the number of rows and the number of columns.


# Use head() to view the first six rows.


# Display only the values of amount two different ways. One uses $amount and the other uses [,2].


# Display only the first two columns using two approaches.


# The text refers to a model matrix such as used in regression. While many regression functions in R handle this automatically, we can also turn a data frame into a design matrix. Suppose we are trying to predict amount based on age and type. The following code creates a model matrix. The first term specifies target and predictor variables. The second identifies the data frame to convert. You will see that an intercept was added (the -1 in the text example indicates to omit that column.) Also note that the function arbitrarily assigned "term" as the base class.

mm <- model.matrix(amount ~ age + type, data = df)
mm
```

```{r}
rm(list = ls())

# Work with the following three vectors:
age <- c(35, 42, 51, 38, 19, 45, 63)
amount <- c(1, 3, 2, 5, 2, 3, 7)
type <- as.factor(c("term", "universal", "term", "whole", "universal", "term", "whole"))

# Use the data.frame function to make a data frame from these three vectors and then display the data frame. Note that these variables were named in advance, so names didn't have to be assigned. Note that the data frame deduced that the first two variables are numeric and the third a factor variable. Assign the name df to your data frame.

df <- data.frame(age, amount, type)

# Determine the number of rows and the number of columns.
nrow(df)
ncol(df)

# Use head() to view the first four rows.
head(df, n = 4)

# Display only the values of amount two different ways. One uses $amount and the other uses [,2].
df$amount
df[, 2]

# Display only the first two columns using [,-3].
df[, -3]
df[, c("age", "amount")]
# Note that df[, -c("type")] will not work. R will not accept a single element as an argument
```

# Reading and Writing Data Section

Work with the following code after reading to Section 6.1.1 and Section 6.6. In this course all supplied data is in csv format so methods of loading other file types will not be necessary.

```{r}
rm(list = ls())

# Use read.csv to read the gapminder data into a data frame called gd. Note that if the file is in your working directory you just need to enclose the file name (including the .csv extension) in quotation marks. You can determine your working directory by the function getwd() in the Console. You can change the working directory via the setwd() function or from the Session menu. Then use head() to see the first six rows and the values of the six variables.

gd <- read.csv("gapminderdatafiveyear.csv", stringsAsFactors = TRUE) # StringAsFactors = TRUE ensures such variables are treated as factor variables and not as character variables. For our applications, factor variables are desired.
head(gd)

# Saving data is not discussed in Chapter 6. The following code does some simple manipulations of the file and then saves it with a new name. After running this chunk, verify that the file is in your working directory and open it in Excel or Notepad to verify the contents.

gd$year <- gd$year - 1950 # subtracts 1950 from each year and replaces the original value.
gd$gdp <- gd$pop * gd$gdpPercap / 1000000 # Calculates total gdp in millions
write.csv(gd, file = "gapMinderNew.csv")

# Note that if you re-run the chunk, R will not warn you that you are overwriting an existing file.
```

Run the following commands to load the ggplot2 package and list the available datasets. Load and save the mpg file as a CSV file. Name the file MilesPerGallon.csv

IMPORTANT: We will use the mpg dataset later on. If you load it this way it is as a "tibble." Tibbles are discussed in R for Everyone. They behave differently from data frames and hence not all functions will work the same way. Since we will not use tibbles in this course, this file should be saved and then read from your directory when needed.

```{r}
library(ggplot2)
data(package = "ggplot2")$result[, "Item"]

miles_per_gallon <- ggplot2::mpg # The ;; notation directs R to look to the ggplot2 pacakge for the desired item. This is needed when multiple packages have the same items or functions.

write.csv(miles_per_gallon, file = "MilesPerGallon.csv", row.names = FALSE) # Setting row.names = FALSE makes it so that the saved file does not have an additional column with the row numbers. Change the value to TRUE to see the difference.
```

# Basic Plots Section

Work with the following code after reading Chapter 7. There will be several chunks to work through the sections of this chapter. Here the plots are made for you. Consider practicing by plotting other variables or changing parameters, such as the bin width in a histogram.

```{r}
rm(list = ls())

# We will work with the mpg dataset seen earlier. The only variables used are displ (engine displacement in liters), cyl (number of cylinders), drv (f-front, r-rear, 4-four wheel), and hwy (highway miles per gallon). The following code loads the data, removes the other variable,s and saves the file in case you want that version of it later.

library(ggplot2)
MPG <- read.csv(file = "MilesPerGallon.csv", stringsAsFactors = TRUE)
MPG <- MPG[, c("displ", "cyl", "drv", "hwy")]
head(MPG)
write.csv(MPG, file = "MPG.csv")

# Use the base graphics to make a histogram of hwy and scatter plots of hwy against each of the three predictor variables.

hist(MPG$hwy)
plot(hwy ~ displ, data = MPG)
plot(hwy ~ cyl, data = MPG)
plot(hwy ~ drv, data = MPG)

# Note that plot seemed to understand that a boxplot would be better for a factor variable.
```

The next several chunks will continue to work with plots, The data have not been cleared, the MPG data frame is still available. The following is from Section 7.2.1 using ggplot for histograms.

```{r}
# Use ggplot to make two histograms of hwy.
library(ggplot2)
library(gridExtra)
h1 <- ggplot(data = MPG, aes(x = hwy)) +
  geom_histogram()
h2 <- ggplot(data = MPG, aes(x = hwy, ..density..)) +
  geom_histogram()

# use the gridExtra package to place both plots on one screen. The following command presents them side by side.
grid.arrange(h1, h2, ncol = 2)

# There is a subtle difference in the two plots. The one on the left is technically not a histogram. It is a bar chart that plots the number of observations in each interval. A true histogram is also a probability density function with the total area being equal to one. The "..density.." item added to the function ensures this happens. If the bin widths are unequal, only the second approach makes a proper histogram.
```

This chunk relates to Section 7.2.2. on scatter plots.

```{r}
# Use ggplot to make a scatter plot of hwy vs disp. Then use color to identify points by cyl.

s1 <- ggplot(data = MPG, aes(x = displ, y = hwy)) +
  geom_point()
s2 <- ggplot(data = MPG, aes(x = displ, y = hwy)) +
  geom_point(aes(color = cyl))

# You will see that when the s2 plot is made the colors for cyl use a gradient because it is considered a continuous numerical variable. The following allows for better separation.

MPG$cyl.factor <- as.factor(MPG$cyl)
s3 <- ggplot(data = MPG, aes(x = displ, y = hwy)) +
  geom_point(aes(color = cyl.factor))
grid.arrange(s1, s2, s3, ncol = 3)
```

This chunk continues 7.2.2 and covers facets.

```{r}
# This one makes a separate scatterplot for each number of cylinders.
ggplot(data = MPG, aes(x = displ, y = hwy)) +
  geom_point(aes(color = cyl.factor)) +
  facet_wrap(~cyl.factor)
```

The next chunk makes two boxplots from Section 7.2.3. We will not cover violin plots.

```{r}
# First boxplot is of hwy. Note the addition of x=1. This is because the program is accustomed to making several boxplots for comparison, but we want only one.
b1 <- ggplot(data = MPG, aes(y = hwy, x = 1)) +
  geom_boxplot()

# This boxplot splits by drv.
b2 <- ggplot(data = MPG, aes(y = hwy, x = drv)) +
  geom_boxplot()

grid.arrange(b1, b2, ncol = 2)
```

The above plot is a good example of the ease of making causal influences when they may not exist. It appears that switching to front-wheel drive will increase highway mileage. But it is more likely that front-wheel drive cars are smaller and that size is the real driver of mileage.

The final chunk makes line graphs from Section 7.2.4. We will not cover themes (Section 7.2.5).

```{r}
# There is nothing in the MPG data worthy of making a line plot. What about just plotting the hwy values as a sequence. we begin by adding the numbers 1 to n to the data frame.

MPG$item <- seq(1:nrow(MPG))

# Here is the code for a line graph.
l1 <- ggplot(data = MPG, aes(x = item, y = hwy)) +
  geom_line()

# Now separate the lines by cyl.factor. Note that you can add to an existing plot rather than repeat the code.

l2 <- l1 + aes(color = cyl.factor)

grid.arrange(l1, l2, ncol = 2)

# Of course, these plots make little sense as the ordering of the values is random.
```

# Writing Functions Section

While it is unlikely you will need to write functions for your exam, it is worth understanding how R functions work, just in case. the following chunks offer an opoprtunity to practice this.

```{r}
rm(list = ls())

# Write a function that calculates the mean and standard deviation for a selected variable number in a dataset.  Try your hand at it here. The next chunk has a solution.

```

Here is a solution. Run the chunk to create the function and than type commands in the Console to see output. For example, meansd(MPG,4) should produce the mean and standard deviation for highway mileage. You could also type meansd(MPG,"hwy").

```{r}
meansd <- function(dataframe, varno) {
  col.vector <- dataframe[, varno]
  m <- mean(col.vector)
  s <- sd(col.vector)

  return(c(m, s))
}
```

# Control Statements Section

We will continue with the function just written and add some if statements. 

Modify the code to first check that the entry for "varno" is an integer and is in the range of the available variables, and if the variable values are numeric. if any of the items is not true, print an appropriate message. Use the next chunk to do that, a solution is provided in the chunk after that.

```{r}
# Modify this code to check if varno is appropriate.
meansd <- function(dataframe, varno) {
  col.vector <- dataframe[, varno]
  m <- mean(col.vector)
  s <- sd(col.vector)

  return(c(m, s))
}
```

```{r}
# Solution
meansd <- function(dataframe, varno) {
  if (floor(varno) != varno) {
    return("varno is not an integer") # Note, is.integer cannot be used as a whole number is likely entered as, say, 4, and not 4L
  }
  if (varno > ncol(dataframe)) {
    return("varno is too large")
  }
  if (varno < 1) {
    return("varno is too small")
  }
  if (is.numeric(dataframe[, varno]) == FALSE) {
    return("varno is not numeric")
  }
  col.vector <- dataframe[, varno]
  m <- mean(col.vector)
  s <- sd(col.vector)

  return(c(m, s))
}

meansd(MPG, 2.5)
meansd(MPG, 10)
meansd(MPG, -1)
meansd(MPG, 3)
meansd(MPG, 4)
```

# Loops Section

Write a simple loop to cycle through the meansd function from column 1 up to the number of columns. You will need to use print inside the loop to display the results.

```{r}

```

```{r}
for (i in 1:ncol(MPG)) {
  print(meansd(MPG, i))
}
```

# rbind and cbind Section

Section 14.1 introduces two simple functions.

```{r}
# Suppose we want to examine the effect of adding an outlier to the MPG data. Here is an easy way to do that.
newcar <- c(1.2, 3, "f", 16)
MPG.outlier <- rbind(MPG, newcar)
tail(MPG.outlier)

# You will see that the new observation has been added as number 235.
```
